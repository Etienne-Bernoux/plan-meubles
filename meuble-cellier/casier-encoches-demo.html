<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Casier encoches croisées — Démo</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #1a1a2e; font-family: 'Segoe UI', sans-serif; }
canvas { display: block; }
#overlay {
  position: absolute; top: 15px; left: 15px;
  background: rgba(0,0,0,0.7); color: #eee;
  padding: 15px 20px; border-radius: 10px;
  font-size: 13px; line-height: 1.8;
  backdrop-filter: blur(10px);
  max-width: 380px;
}
#overlay h2 { font-size: 16px; margin-bottom: 8px; color: #f0a040; }
</style>
</head>
<body>

<div id="overlay">
  <h2>Casier à encoches croisées</h2>
  <span style="color:#aaa;">Principe : des planches avec des encoches à mi-hauteur<br>
  qui s'emboîtent perpendiculairement — comme un casier à œufs.<br><br>
  <span style="color:#C4A265;">Beige</span> = planches longitudinales (encoches vers le bas)<br>
  <span style="color:#8B6914;">Foncé</span> = planches transversales (encoches vers le haut)<br>
  <span style="color:#2d5a1b;">Vert</span> = bouteilles 75cl<br><br>
  Avantages : démontable, peu de matière, scie plongeante suffit</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1a2e);
const camera = new THREE.PerspectiveCamera(40, innerWidth/innerHeight, 1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const sun = new THREE.DirectionalLight(0xffffff, 0.7);
sun.position.set(100, 200, 150);
scene.add(sun);
scene.add(new THREE.DirectionalLight(0xffffff, 0.3)).position.set(-80, 60, -80);

// Matériaux
const matLong = new THREE.MeshStandardMaterial({ color: 0xC4A265, roughness: 0.8 });
const matTrans = new THREE.MeshStandardMaterial({ color: 0x8B6914, roughness: 0.8 });
const matBottle = new THREE.MeshStandardMaterial({ color: 0x2d5a1b, transparent: true, opacity: 0.7 });
const edgeMat = new THREE.LineBasicMaterial({ color: 0x8B7355, transparent: true, opacity: 0.4 });

// Dimensions (cm)
const T = 1.8;           // épaisseur OSB
const cellW = 10;        // largeur cellule
const cellH = 10;        // hauteur cellule
const boardH = cellH;    // hauteur planche
const slotDepth = boardH / 2;  // encoche à mi-hauteur
const D = 34;            // profondeur (longueur bouteille 75cl couchée)
const cols = 8;          // colonnes
const rows = 4;          // rangées

const totalW = cols * cellW + (cols + 1) * T;
const totalH = rows * cellH + (rows + 1) * T;

const group = new THREE.Group();

function box(parent, w, h, d, x, y, z, mat) {
  const g = new THREE.BoxGeometry(w, h, d);
  const m = new THREE.Mesh(g, mat);
  m.position.set(x, y, z);
  parent.add(m);
  // edges
  const edges = new THREE.EdgesGeometry(g);
  const line = new THREE.LineSegments(edges, edgeMat);
  line.position.copy(m.position);
  parent.add(line);
}

// Planches longitudinales (sens de la profondeur) — encoches vers le bas
// Ce sont les "murs" qui séparent les colonnes (parallèles à Z)
for (let c = 0; c <= cols; c++) {
  const x = -totalW/2 + c * (cellW + T) + T/2;

  // Partie haute (au-dessus des encoches) — continue sur toute la profondeur
  for (let r = 0; r < rows; r++) {
    const y = r * (cellH + T) + T + slotDepth;
    // Segments entre les encoches
    for (let seg = 0; seg <= rows; seg++) {
      // Planche complète sur toute la profondeur, avec encoches simulées
    }
  }

  // Simplifié : on dessine la planche entière sur toute la hauteur
  // avec les encoches découpées
  for (let r = 0; r <= rows; r++) {
    const baseY = r * (cellH + T);

    if (r < rows) {
      // Partie haute de la cellule (au-dessus de l'encoche)
      const topPartH = slotDepth;
      const topY = baseY + T + slotDepth + topPartH/2;
      box(group, T, topPartH, D, x, topY, 0, matLong);
    }

    if (r > 0) {
      // Partie basse de la cellule (en dessous de l'encoche)
      const botPartH = slotDepth;
      const botY = baseY + T/2 + botPartH/2;
      // Cette partie est coupée par les transversales — on la met quand même
      // car les encoches des longitudinales sont en bas
    }
  }
}

// En fait, simplifions : planches complètes sans découpe visible
// Longitudinales (séparateurs de colonnes, parallèles à Z)
for (let c = 0; c <= cols; c++) {
  const x = -totalW/2 + c * (cellW + T) + T/2;
  for (let r = 0; r < rows; r++) {
    const baseY = r * (cellH + T) + T;
    // Moitié haute (encoches en bas = on garde le haut)
    box(group, T, slotDepth, D, x, baseY + slotDepth + slotDepth/2, 0, matLong);
    // Moitié basse entre les transversales
    box(group, T, slotDepth, D, x, baseY + slotDepth/2, 0, matLong);
  }
}

// Transversales (séparateurs de rangées, parallèles à X)
for (let r = 0; r <= rows; r++) {
  const y = r * (cellH + T) + T/2;
  for (let c = 0; c < cols; c++) {
    const x = -totalW/2 + c * (cellW + T) + T + cellW/2;
    // Planche transversale avec encoches vers le haut
    // Moitié basse (on garde le bas)
    box(group, cellW, slotDepth, T, x, y + slotDepth/2 - T/2, 0, matTrans);
  }
}

// Ah, c'est trop compliqué avec les demi-planches. Refaisons proprement.
// On va juste montrer le principe visuellement.

// Nettoyons et recommençons simplement
while(group.children.length) group.remove(group.children[0]);

// Approche simple : montrer des planches qui se croisent avec des encoches visibles
const casier = new THREE.Group();

// Planches longitudinales (parallèles à Z, séparent les colonnes)
for (let c = 0; c <= cols; c++) {
  const x = -totalW/2 + c * (cellW + T) + T/2;

  for (let r = 0; r < rows; r++) {
    const rowBaseY = r * (cellH + T);
    // Haut de la cellule (au-dessus de mi-hauteur) — pas d'encoche ici
    const topH = cellH / 2 + T;
    const topY = rowBaseY + cellH/2 + T + topH/2;
    box(casier, T, topH, D, x, topY, 0, matLong);

    // Bas de la cellule : segments entre les transversales
    // (coupé par les encoches des transversales)
  }
}

// Planches transversales (parallèles à X, séparent les rangées)
const nbTransZ = Math.floor(D / (cellW + T));
for (let tz = 0; tz < nbTransZ; tz++) {
  const z = -D/2 + T/2 + tz * (cellW + T) + (cellW + T)/2;

  for (let r = 0; r <= rows; r++) {
    const rowBaseY = r * (cellH + T);
    // Bas de la rangée (en dessous de mi-hauteur)
    const botH = cellH / 2;
    const botY = rowBaseY + T/2 + botH/2;
    if (r > 0) {
      box(casier, totalW, botH, T, 0, botY, z, matTrans);
    } else {
      box(casier, totalW, T, T, 0, T/2, z, matTrans);
    }
  }
}

// Trop compliqué, faisons VRAIMENT simple
while(casier.children.length) casier.remove(casier.children[0]);

// VERSION CLAIRE : grille simple montrant le principe d'emboîtement
const demo = new THREE.Group();

const COLS = 5, ROWS = 3, CELL = 10, DEPTH = 32;
const TW = COLS * CELL;  // largeur totale intérieure
const TH = ROWS * CELL;  // hauteur totale intérieure

// Planches verticales (longitudinales, sens profondeur)
// Encoches vers le BAS (on enlève la moitié basse aux croisements)
for (let c = 0; c <= COLS; c++) {
  const x = c * CELL - TW/2;
  box(demo, T, TH, DEPTH, x, TH/2, 0, matLong);
}

// Planches horizontales (transversales, sens largeur)
// Encoches vers le HAUT (on enlève la moitié haute aux croisements)
for (let r = 0; r <= ROWS; r++) {
  const y = r * CELL;
  box(demo, TW + T, T, DEPTH, 0, y, 0, matTrans);
}

// Bouteilles dans quelques cellules
for (let c = 0; c < COLS; c++) {
  for (let r = 0; r < ROWS; r++) {
    if (Math.random() > 0.4) {
      const bx = c * CELL - TW/2 + CELL/2;
      const by = r * CELL + CELL/2;
      // Bouteille couchée (cylindre horizontal le long de Z)
      const bottleGeo = new THREE.CylinderGeometry(3.7, 3.7, 30, 12);
      bottleGeo.rotateX(Math.PI/2);
      const bottle = new THREE.Mesh(bottleGeo, matBottle);
      bottle.position.set(bx, by, 0);
      demo.add(bottle);
    }
  }
}

scene.add(demo);

// Grille au sol
const grid = new THREE.GridHelper(200, 20, 0x333355, 0x222244);
scene.add(grid);

// Caméra
camera.position.set(50, 40, 70);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, TH/2, 0);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.autoRotate = true;
controls.autoRotateSpeed = 1.0;
controls.update();

addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

(function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
})();
</script>
</body>
</html>
